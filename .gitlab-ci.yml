image: alpine

variables:
  STACK_ROOT: "${CI_PROJECT_DIR}/.stack"
  IMAGE_NAME: ${CI_REGISTRY_IMAGE}:${CI_COMMIT_REF_SLUG}_${CI_COMMIT_SHA}

cache:
  key: primary
  paths:
    - .stack
    - .stack-work

stages:
  - build
  - test
  - deploy

build:
  stage: build
  image: haskell
  # See https://gitlab.com/gitlab-org/gitlab-runner/issues/2838
  cache:
    key: primary
    policy: pull # Only push from test (even though it runs later)
    paths:
      - .stack
      - .stack-work
  script:
    - mkdir bin
    - stack upgrade
    - stack install --local-bin-path ./bin
  artifacts:
    expire_in: 1 week
    paths:
      - bin/

test:
  stage: test
  image: haskell
  dependencies: []
  script:
    - stack upgrade
    - stack test --coverage
    - mkdir coverage
    - cp -a $(stack path --local-hpc-root)/. ./coverage/
  artifacts:
    expire_in: 1 week
    paths:
      - coverage/

image_build:
  stage: test # if on master, run alongside tests
  image: docker
  services:
    - docker:dind
  cache: {}
  dependencies:
    - build
  script:
    - docker login -u gitlab-ci-token -p "$CI_BUILD_TOKEN" "$CI_REGISTRY"
    - docker build -t "$IMAGE_NAME" .
    - docker push "$IMAGE_NAME"
  only:
    - master

deploy_image:
  stage: deploy
  image: lachlanevenson/k8s-kubectl
  environment:
    name: dev
  cache: {}
  dependencies: []
  script:
    - cd deploycfg
    - sed -i "s/__CI_ENVIRONMENT_SLUG__/${CI_ENVIRONMENT_SLUG}/" dev.yml service.yml
    - sed -i "s/__IMAGE__/$(echo ${IMAGE_NAME} | sed -e 's/\//\\\//g')/" dev.yml
    - kubectl apply -f dev.yml
    - kubectl apply -f service.yml
    - kubectl rollout status -f dev.yml
  only:
    - master

pages:
  stage: deploy
  cache: {}
  dependencies:
    - test
  script:
    - mkdir -p public/coverage
    - mv coverage/ public/
  artifacts:
    paths:
    - public
    expire_in: 30 days
  only:
    - master